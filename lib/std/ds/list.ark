#use std::mem

pub type List struct<T> {
    data: []T,
    length: uint,
    capacity: uint,
};

BaseCapacity: uint = 4;

pub func (List) new<T>(mut cap: uint) -> ^mut List<T> {
    if cap <= 0 {
        cap = BaseCapacity;
    }

    // TODO: Fix the lexer to allow >> here but still parse shift ops
    res := mem::alloc<List<T> >();
    @res = List<T>{
        data: mem::allocArray<T>(cap),
        length: 0,
        capacity: cap,
    };
    
    return res;
}

pub func (it: ^List<T>) destroy() {
    mem::freeArray(it.data);
    mem::free(it);
}

pub func (it: ^List<T>) toRawPointer() -> ^T {
    return ^it.data[0];
}

func (it: ^mut List<T>) grow() {
    oldData := it.data;
    newCap := it.capacity * 2;
    it.data = mem::allocArray<T>(newCap);
    mem::copyArray(it.data, oldData, it.length);
    mem::freeArray(oldData);
}

pub func (it: ^mut List<T>) append(value: T) {
    if it.length == it.capacity {
        it.grow();
    }
    
    it.data[it.length] = value;
    it.length += 1;
}