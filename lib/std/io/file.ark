#use std::mem
#use std::string

pub type FileMode enum {
	Read,
	Write,
	Append,
};

pub type File struct {
	name: string,
	path: ^u8,
	handle: ^FILE,
};

READ_FLAG := c"r";
WRITE_FLAG := c"w";
APPEND_FLAG := c"a";

pub func (File) open(path: ^u8, mode: FileMode) -> Option<^mut File> {
	mut f: ^mut File = mem::alloc<File>();
	f.path = path;
	f.handle = C::fopen(path, mode.getLegacyFileMode());

	if f.handle == (^FILE)(0) {
		// failed to read
		return Option::None;
	}

	return Option::Some(f);
}

pub func (f: ^mut File) readToString() -> string {
	return f.name;
}

pub func (f: ^mut File) destroy() {
	if f.handle != (^FILE)(0) {
		C::fclose(f.handle);
	}
	mem::free(f);
}

/*
	Note this is just placeholder stuff...
	none of this really means anything and
	most of these are somewhat arbitrarily
	chosen... lol
*/
pub func (f: FileMode) getLegacyFileMode() -> ^u8 {
	match f {
		FileMode::Read => {
			return READ_FLAG;
		},
		FileMode::Write => {
			return WRITE_FLAG;
		},
		FileMode::Append => {
			return APPEND_FLAG;
		},
		_ => {
			return READ_FLAG;
		},
	}
	return READ_FLAG;
}

// C stuff for
// loading files

type FILE struct {};

[c] func fopen(loc: ^u8, mode: ^u8) -> ^FILE;
[c] func fseek(handle: ^FILE, offset: uint, whence: uint);
[c] func ftell(handle: ^FILE) -> uint;
[c] func rewind(handle: ^FILE);
[c] func fread(where: ^u8, sz: uint, dunno: uint, handle: ^FILE);
[c] func fclose(handle: ^FILE);
[c] func getenv(what: ^u8) -> ^u8;