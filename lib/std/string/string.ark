#use std::adt
#use std::mem
#use std::unicode::utf8

/*
	Implementation of a 
	dynamic string type.
*/

pub type String struct {
	data: ^mut adt::List<rune>,	
};

// create a dynamic string from the given
// static string
pub func (String) from(source: string) -> ^mut String {
	str := String::withCapacity(len(source));
	mut idx := uint(0);
	for idx < len(source) {
		char := []u8{source[idx]};
		decodedChar := []rune{0};
		decodeChar := utf8::decode(decodedChar, char);
		str.append(decodedChar[0]);
		idx += 1;
	}
	return str;
}

pub func (String) withCapacity(size: uint) -> ^mut String {
	str := mem::alloc<String>();
	@str = String {
		data: adt::List::newWithCapacity<rune>(size),
	};

	mut idx := uint(0);
	for idx < size {
		str.append('\0');
		idx += 1;
	}

	return str;
}

/// Clear the entire string
/// returning it back to a length
/// of zero.
pub func (a: ^String) clear() {
	mut idx := uint(0);
	for idx < a.length() {
		a.pop();
		idx += 1;
	}
}

/// Pops and returns the last rune
/// in the string
pub func (a: ^String) pop() -> Option<rune> {
	if a.length() == 0 {
		return Option::None;
	}
	return a.data.pop();
}

/// Append a string
pub func (a: ^String) concat(other: string) {
	mut idx := uint(0);
	for idx < len(other) {
		otherRunePointer := uintptr(other[idx]);
		a.append((rune)(otherRunePointer));
		idx += 1;
	}
}

/// Append a single rune
pub func (a: ^String) append(char: rune) {
	a.data.append(char);
}

pub func (a: ^String) at(index: uint) -> rune {
	return a.data.get(index);
}

pub func (a: ^String) length() -> uint {
	return a.data.getLength();
}

pub func (a: ^String) destroy() {
	a.data.destroy();
	mem::free(a);
}
