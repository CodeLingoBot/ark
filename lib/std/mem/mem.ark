[c] func malloc(size: uint) -> ^C::void;
[c] func realloc(ptr: ^C::void, size: uint) -> ^C::void;
[c] func free(ptr: ^C::void);

// TODO: check for overflow when doing `num * sizeof(T)``

pub func alloc<T>() -> ^mut T {
    ptr := C::malloc(sizeof(T));
    return (^mut T)(uintptr(ptr));
}

// can we maybe move this to mem/array.ark?
type RawArray struct {
    size: uint,
    ptr: ^u8,
};

pub func allocArray<T>(num: uint) -> []T {
    ptr := C::malloc(sizeof(T) * num);

    rawPtr := (^u8)(uintptr(ptr));

    rawArray := RawArray{
        size: num,
        ptr: rawPtr,
    };

    arrPtr := (^[]T)(uintptr(^rawArray));

    return @arrPtr;
}

pub func copyArray<T>(mut dest: []T, src: []T, num: uint) {
    mut max := num;
    if max > len(dest) {
        max = len(dest);
    }
    if max > len(src) {
        max = len(src);
    }

    mut i: uint = 0;
    for i < max {
        dest[i] = src[i];
        i += 1;
    }
}

pub func free<T>(ptr: ^T) {
    C::free((^C::void)(uintptr(ptr)));
}

pub func freeArray<T>(array: []T) {
    mut rawArray := @((^RawArray)(uintptr(&array)));
    C::free((^C::void)(uintptr(rawArray.ptr)));
}
